# 错误码规范化完成总结

> 完成时间: 2024-12-05 06:55  
> 任务状态: ✅ 已完成

---

## 📋 完成内容

### 1. 后端错误码系统

#### ✅ 错误码枚举定义
**文件**: `server-nestjs/src/common/enums/error-code.enum.ts`

定义了完整的业务错误码体系:
- **通用错误** (1xxxx): 参数错误、数据不存在、操作被拒绝等
- **认证授权** (2xxxx): 未登录、Token过期、无权限等
- **用户管理** (3xxxx): 用户不存在、用户名已存在等
- **角色管理** (4xxxx): 角色不存在、角色已分配用户等
- **部门管理** (5xxxx): 部门不存在、部门有子部门等
- **菜单管理** (6xxxx): 菜单不存在、菜单有子菜单等
- **字典管理** (7xxxx): 字典类型不存在等
- **岗位管理** (71xxx): 岗位不存在等
- **系统配置** (8xxxx): 参数配置不存在等
- **监控日志** (9xxxx): 日志不存在、任务不存在等

**总计**: 50+ 个业务错误码

#### ✅ 自定义异常类
**文件**: `server-nestjs/src/common/exceptions/business.exception.ts`

创建了 `BusinessException` 类:
- 支持错误码、自定义消息、额外数据
- 提供静态工厂方法快速创建异常
- 自动映射错误码到默认消息
- 支持自定义 HTTP 状态码

#### ✅ 全局异常过滤器增强
**文件**: `server-nestjs/src/common/filters/all-exceptions.filter.ts`

更新了全局异常过滤器:
- 优先处理 `BusinessException`
- 统一返回格式: `{ code, msg, data }`
- 记录业务异常日志
- 保留原有异常处理逻辑

#### ✅ 使用示例
**文件**: `server-nestjs/src/common/exceptions/usage-example.ts`

提供了 10+ 个使用示例:
- 基本用法
- 自定义消息
- 携带额外数据
- 静态工厂方法
- 权限验证
- 参数验证
- 业务规则验证
- Controller 中使用
- Service 中使用
- 分类使用

### 2. 前端错误码适配

#### ✅ 错误码定义
**文件**: `web/src/types/error-code.ts`

创建了前端错误码系统:
- 与后端保持一致的错误码定义
- 错误码消息映射
- 工具函数:
  - `getErrorMessage()` - 获取错误消息
  - `shouldRedirectToLogin()` - 判断是否需要跳转登录
  - `isForbiddenError()` - 判断是否是权限错误

---

## 🎯 使用方法

### 后端使用

#### 方式1: 直接使用错误码

```typescript
import { BusinessException } from '@/common/exceptions';
import { ErrorCode } from '@/common/enums';

// 抛出异常
throw new BusinessException(ErrorCode.USER_NOT_FOUND);
// 返回: { code: 30001, msg: '用户不存在', data: null }
```

#### 方式2: 自定义消息

```typescript
throw new BusinessException(
  ErrorCode.USER_NOT_FOUND,
  `用户 ${userId} 不存在`
);
// 返回: { code: 30001, msg: '用户 123 不存在', data: null }
```

#### 方式3: 携带额外数据

```typescript
throw new BusinessException(
  ErrorCode.USERNAME_EXISTS,
  '用户名已存在',
  { username, suggestion: '请尝试其他用户名' }
);
// 返回: { 
//   code: 30002, 
//   msg: '用户名已存在', 
//   data: { username: 'admin', suggestion: '请尝试其他用户名' }
// }
```

#### 方式4: 使用静态工厂方法

```typescript
// 更简洁的写法
throw BusinessException.notFound('用户不存在');
throw BusinessException.invalidParams('参数错误');
throw BusinessException.unauthorized('未登录');
throw BusinessException.forbidden('无权限');
throw BusinessException.denied('操作被拒绝');
```

#### 实际示例: Service 中使用

```typescript
@Injectable()
export class UserService {
  async deleteUser(userId: string, currentUserId: string) {
    // 不能删除自己
    if (userId === currentUserId) {
      throw new BusinessException(ErrorCode.CANNOT_DELETE_SELF);
    }
    
    const user = await this.findUser(userId);
    if (!user) {
      throw new BusinessException(ErrorCode.USER_NOT_FOUND);
    }
    
    // 不能删除超级管理员
    if (user.userId === BigInt(1)) {
      throw new BusinessException(ErrorCode.CANNOT_DELETE_ADMIN);
    }
    
    // 检查用户是否有角色
    const hasRoles = await this.userHasRoles(userId);
    if (hasRoles) {
      throw new BusinessException(
        ErrorCode.USER_HAS_ROLES,
        '该用户已分配角色,请先解除角色关联'
      );
    }
    
    // 执行删除
    await this.prisma.sysUser.update({
      where: { userId: BigInt(userId) },
      data: { delFlag: '2' },
    });
    
    return true;
  }
}
```

### 前端使用

#### 在请求拦截器中处理

```typescript
import { ErrorCode, shouldRedirectToLogin, getErrorMessage } from '@/types/error-code'
import { useRouter } from 'vue-router'
import { useToast } from '@/components/ui/toast'

// 响应拦截器
axios.interceptors.response.use(
  (response) => {
    const { code, msg, data } = response.data
    
    // 成功
    if (code === ErrorCode.SUCCESS || code === 200) {
      return data
    }
    
    // 需要跳转登录
    if (shouldRedirectToLogin(code)) {
      toast({
        title: '登录已过期',
        description: msg || getErrorMessage(code),
        variant: 'destructive',
      })
      router.push('/login')
      return Promise.reject(new Error(msg))
    }
    
    // 其他错误
    toast({
      title: '操作失败',
      description: msg || getErrorMessage(code),
      variant: 'destructive',
    })
    
    return Promise.reject(new Error(msg))
  },
  (error) => {
    // 处理网络错误
    return Promise.reject(error)
  }
)
```

#### 在组件中使用

```typescript
import { ErrorCode } from '@/types/error-code'

async function handleDelete(userId: string) {
  try {
    await deleteUser(userId)
    toast({ title: '删除成功' })
  } catch (error: any) {
    // 根据错误码做特殊处理
    if (error.code === ErrorCode.CANNOT_DELETE_SELF) {
      toast({
        title: '无法删除',
        description: '不能删除当前登录用户',
        variant: 'destructive',
      })
    } else if (error.code === ErrorCode.USER_HAS_ROLES) {
      toast({
        title: '无法删除',
        description: '该用户已分配角色,请先解除角色关联',
        variant: 'destructive',
      })
    }
  }
}
```

---

## 📊 错误码分类

### 通用错误 (1xxxx)
| 错误码 | 说明 |
|--------|------|
| 10001 | 参数错误 |
| 10002 | 数据不存在 |
| 10003 | 数据已存在 |
| 10004 | 操作被拒绝 |
| 10005 | 数据库操作失败 |
| 10006 | 系统内部错误 |

### 认证授权 (2xxxx)
| 错误码 | 说明 |
|--------|------|
| 20001 | 未登录或登录已过期 |
| 20002 | 登录失败 |
| 20003 | 用户名或密码错误 |
| 20004 | Token 无效 |
| 20005 | Token 已过期 |
| 20006 | 无权限访问 |
| 20007 | 账号已被停用 |
| 20008 | 账号已被锁定 |

### 用户管理 (3xxxx)
| 错误码 | 说明 |
|--------|------|
| 30001 | 用户不存在 |
| 30002 | 用户名已存在 |
| 30003 | 手机号已存在 |
| 30004 | 邮箱已存在 |
| 30005 | 原密码错误 |
| 30006 | 新密码不能与原密码相同 |
| 30007 | 不能删除当前登录用户 |
| 30008 | 不能删除超级管理员 |
| 30009 | 用户已分配角色,不能删除 |

### 角色管理 (4xxxx)
| 错误码 | 说明 |
|--------|------|
| 40001 | 角色不存在 |
| 40002 | 角色名称已存在 |
| 40003 | 角色权限字符已存在 |
| 40004 | 不能删除超级管理员角色 |
| 40005 | 角色已分配用户,不能删除 |
| 40006 | 角色已分配权限,不能删除 |

### 部门管理 (5xxxx)
| 错误码 | 说明 |
|--------|------|
| 50001 | 部门不存在 |
| 50002 | 部门名称已存在 |
| 50003 | 父部门不存在 |
| 50004 | 不能将部门设置为自己的子部门 |
| 50005 | 部门存在子部门,不能删除 |
| 50006 | 部门已分配用户,不能删除 |
| 50007 | 部门状态异常 |

*更多错误码请查看源文件*

---

## 💡 最佳实践

### 1. 错误码命名规范

- 使用大写字母和下划线
- 语义清晰,见名知意
- 按模块分类,便于管理

### 2. 错误消息编写

- 简洁明了,用户友好
- 提供解决建议(可选)
- 避免暴露敏感信息

### 3. 异常抛出时机

- 业务规则验证失败
- 数据不存在或已存在
- 权限不足
- 操作被拒绝

### 4. 前后端协作

- 保持错误码定义一致
- 前端根据错误码做特殊处理
- 统一错误提示风格

---

## 📁 新增文件清单

### 后端 (4个)
1. `server-nestjs/src/common/enums/error-code.enum.ts` - 错误码枚举
2. `server-nestjs/src/common/enums/index.ts` - 枚举导出
3. `server-nestjs/src/common/exceptions/business.exception.ts` - 业务异常类
4. `server-nestjs/src/common/exceptions/index.ts` - 异常导出
5. `server-nestjs/src/common/exceptions/usage-example.ts` - 使用示例

### 前端 (1个)
1. `web/src/types/error-code.ts` - 错误码定义

### 修改文件 (1个)
1. `server-nestjs/src/common/filters/all-exceptions.filter.ts` - 增强异常过滤器

---

## 🔄 后续建议

### 1. 逐步重构现有代码

不需要一次性重构所有代码,可以:
- ✅ 新代码使用新的错误码系统
- ⏳ 旧代码遇到修改时逐步重构
- ⏳ 核心模块优先重构

### 2. 补充错误码

根据实际业务需要,可以继续添加:
- 更细粒度的错误码
- 特定业务场景的错误码
- 第三方服务相关错误码

### 3. 错误码文档

可以生成一份完整的错误码文档:
- 所有错误码列表
- 错误码说明
- 处理建议
- 示例代码

### 4. 监控和统计

可以添加错误码监控:
- 统计各错误码出现频率
- 分析常见错误原因
- 优化用户体验

---

## ✅ 优势

### 1. 统一规范

- ✅ 前后端错误码一致
- ✅ 错误消息统一管理
- ✅ 便于维护和扩展

### 2. 类型安全

- ✅ TypeScript 类型检查
- ✅ 避免硬编码错误码
- ✅ IDE 自动补全

### 3. 易于使用

- ✅ 静态工厂方法
- ✅ 自动消息映射
- ✅ 丰富的使用示例

### 4. 便于调试

- ✅ 错误码快速定位问题
- ✅ 统一日志格式
- ✅ 便于错误追踪

---

## 📚 参考资料

- [错误码枚举定义](../../server-nestjs/src/common/enums/error-code.enum.ts)
- [业务异常类](../../server-nestjs/src/common/exceptions/business.exception.ts)
- [使用示例](../../server-nestjs/src/common/exceptions/usage-example.ts)
- [前端错误码](../../web/src/types/error-code.ts)

---

**错误码规范化完成!** 🎉  
现在可以使用统一的错误码系统,提升代码质量和用户体验!

**最后更新**: 2024-12-05 06:55
